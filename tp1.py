# -*- coding: utf-8 -*-
"""TP1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14dzOJL5Q6G5LPK_usrN85YlRc9xxq7xg

# Librairies externes utilisées

## Visualisation
Permet de créer les graphiques.
- matplotlib
- seaborn

## Calculs
- numpy : permet de travailler avec des tableaux de manière plus efficiente/efficace (boucles implicites...)

# Vocabulaire :
- Probability density function = PDF = fonction de densité.
- Cumulative density function = CDF = fonction de répartition.
"""

import numpy as np
import scipy
import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd
import math

import itertools
from functools import partial
from typing import Callable, Any, List

"""# Test du Khi²
Formule p84 du cours, "test du Khi²"
"""

""" 
Second return: the ddof, degree of freedom.
Simplified version of this formula:
dof = (len(df.columns)-1)*(len(df.index)-1)
Because I have two columns (nb_consta, nb_theo)
2 - 1 -> 1, so ignore it.
"""
def test_khi2(nb_consta, nb_theo):
    # sum of (Nb_consta - Nb_théo)² / Nb_théo
    ni = [(consta - theo)**2/theo for consta, theo in zip(nb_consta, nb_theo)]
    return np.sum(ni), len(nb_consta)-1

"""# Loi uniforme"""
N = int(input("Entrer N, le nombre de 'tirage'"))

# Tirage de valeurs entre [0,1], suivant une loi uniforme.
U = np.random.uniform(size=N)

a = 5
b = 10
x = np.linspace(0, 12, 20)

"""## Visualisation"""

# plt.plot(x, y_theoretical, label='théorique')

# Plot uniform histogram, this way I can see it's uniform without a proper stat test.
n, bins, patches = plt.hist(U, facecolor='blue')
plt.xlim(min(bins), max(bins))
plt.grid(axis='y', alpha=0.75)
plt.title("Uniform Histogram")
plt.xlabel("Value")
plt.ylabel("Frequency")
plt.show()

"""## Vérification"""



"""# Loi exponentielle
Référence du cours p83, 3.1 "Génération de la loi exponentielle et de la loi de Weibull"

On génère une variable aléatoire qui suit une loi exponentielle à partir d'une loi uniforme grâce à la "Méthode de la transformée inverse". https://fr.wikipedia.org/wiki/M%C3%A9thode_de_la_transform%C3%A9e_inverse
"""

U = np.random.uniform(size=N)

def generate_exponential_law(lamb, uniform_values):
    return (-1/lamb) * np.log(1 - uniform_values)

lamb = 1/5
U_expo = generate_exponential_law(lamb, U)
print(U_expo)

nb_consta, bins, patches = plt.hist(U_expo)
plt.title("Exponential from Uniform Histogram")
plt.xlabel("Value")
plt.ylabel("Frequency")
plt.show()

"""## Visualisation
Visualisation de la loi exponentielle.
"""

x = np.linspace(0, 25, 100)
x = np.linspace(0, 40, 1000)

y_theoretical = lamb * np.exp(-lamb*x)
# or via the library:
# y_theoretical = scipy.stats.expon.pdf(x, 0, 1)

# Y = 1 - np.exp(-lamb * x)

fig, axes = plt.subplots(2, 1)

axes[0].plot(x, y_theoretical, label='théorique')
sns.kdeplot(U_expo, ax=axes[0], label='pratique')

plt.show()

"""## Vérification
Afin de vérifier que notre variable aléatoire suit une loi exponentielle, on génère les valeurs théoriques, à partir de sa fonction de répartition, puis on applique notre test du Ki².
"""

# expected = [exp_probability(lamb, a, b) * N for a,b in pairwise(bins)]

f = partial(exp_probability, lamb)
expected = expected_frequency(f, N, bins)

len(expected), len(nb_consta)
numbers = {
    'expected': expected,
    'empirical': nb_consta
}

"""
We have 11 bins, we remove the last one.

It's because the "histogram" does, for example:
col 1 : 2.20756934e-04 1.00172758e-01
col 2 : 1.00172758e-01 2.00124760e-01
so 10 cols based on 11 bins.
"""
df = pd.DataFrame(numbers, bins[:-1])
df

test_perso, ddof = test_khi2(nb_consta, expected)

tstat_scipy, pval_scipy, ddof_scipy, exp_scipy = scipy.stats.chi2_contingency(df, correction=False)
print(f"Chi-squared test statistic without Yates correction (Scipy): {tstat_scipy}")
print(f"pval from scypi: {pval_scipy}")
print(f"ddof_scipy: {ddof_scipy} vs ddof: {ddof}")
print("Value from test_perso:", test_perso)

"""# Loi de Weibull
Même méthode que la loi exponentielle.
Référence : cours p83 "Une loi de Weibull".
"""

U = np.random.uniform(size=N)

def generate_weibull_law(uniform_values, alpha, beta):
    a = -np.log(1 - uniform_values)/np.power(alpha, beta)
    b = 1/beta

    return a/b

U_weibull = generate_weibull_law(U, 1, 1)

nb_consta, bins, patches = plt.hist(U_weibull)
plt.title("Exponential from Uniform Histogram")
plt.xlabel("Value")
plt.ylabel("Frequency")
plt.show()

"""# Loi normale
Référence p84 du cours, utilisation de la méthode de Box et Müller.
"""

def generate_normale_law():
    # génération de deux v.a indépendantes, uniformes sur [0;1]
    U = np.random.uniform(size=N)
    V = np.random.uniform(size=N)

    theta = 2 * np.pi * V
    R = -2 * np.log(U)

    X = np.sqrt(R) * np.cos(theta)
    Y = np.sqrt(R) * np.sin(theta)

    return X, Y

X, Y = generate_normale_law()
x_y_corrcoef = np.corrcoef(X, Y)[0][1]
# nearly 0 correlation between z1 and z2. (Zero correlation does not imply independence. 
print(x_y_corrcoef)

"""## Visualisation"""

# Distribution normale théorique sur x [-4;4]
x = np.linspace(-4, 4, 1000)
y_theoretical = scipy.stats.norm.pdf(x)

fig, axes = plt.subplots(2, 1)

axes[0].plot(x, y_theoretical, label='théorique')
sns.kdeplot(X, ax=axes[0], label='pratique X')

axes[1].plot(x, y_theoretical, label='théorique')
sns.kdeplot(Y, ax=axes[1], label='pratique Y')
plt.show()

"""## Vérification"""

